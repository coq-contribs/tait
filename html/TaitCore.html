<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf8"><link rel="stylesheet" href="style.css" type="text/css"><title>TaitCore</title>
</head>

<body>

<h1>Library TaitCore</h1>

<code>
<code class="keyword">Require</code> <code class="keyword">Export</code> <a href="Typing.html">Typing</a>. <br/>

<br/>
Set <code class="keyword">Implicit</code> Arguments.<br/>

<br/>
<code class="keyword">Inductive</code> <a name="prod"></a>prod (A B:Type) : Type :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a name="pair"></a>pair : A -&gt; B -&gt; prod A B.<br/>
<code class="keyword">Notation</code> "x * y" := (<a href="TaitCore.html#prod">prod</a> x y) : type_scope.<br/>

<br/>
<code class="keyword">Definition</code> <a name="fst"></a>fst (A B:Type)(ab:prod A B) := let (a,_) := ab in a.<br/>
<code class="keyword">Definition</code> <a name="snd"></a>snd (A B:Type)(ab:prod A B) := let (_,b) := ab in b.<br/>

<br/>
<code class="keyword">Inductive</code> <a name="halfprod"></a>halfprod (A:Prop)(B:Type) : Type := <br/>
&nbsp;&nbsp;&nbsp;<a name="halfpair"></a>halfpair : A -&gt; B -&gt; halfprod A B. <br/>
<code class="keyword">Notation</code> "x ** y" := (halfprod x y) (at level 40) : type_scope.<br/>

<br/>
<code class="keyword">Definition</code> <a name="F"></a>F (ρs:context)(ρ:type)(r:term)(k:nat) := <br/>
&nbsp;&nbsp;TypJ ρs r ρ /\ length ρs &lt;= k.<br/>

<br/>
<code class="keyword">Hint</code> Unfold F.<br/>

<br/>
<code class="keyword">Lemma</code> <a name="F_occurs"></a>F_occurs : forall r ρs ρ k, <br/>
&nbsp;&nbsp;F ρs ρ r k -&gt; occurs k r = false.  <br/>

<br/>
<code class="keyword">Module Type</code> <a name="Requirements"></a>Requirements.<br/>

<br/>
&nbsp;<code class="keyword">Parameter</code> <a name="abstr"></a>abstr : nat -&gt; type -&gt; term -&gt; term. <br/>
&nbsp;<code class="keyword">Notation</code> " λ k : ρ , r " := (abstr k ρ r) (at level 20, k at level 99).<br/>

<br/>
&nbsp;<code class="keyword">Parameter</code> <a name="N"></a>N : context -&gt; type -&gt; term -&gt; term -&gt; Prop.<br/>
&nbsp;<code class="keyword">Parameter</code> <a name="A"></a>A : context -&gt; type -&gt; term -&gt; term -&gt; Prop.<br/>
&nbsp;<code class="keyword">Parameter</code> <a name="H"></a>H : context -&gt; type -&gt; term -&gt; term -&gt; Prop.<br/>

<br/>
&nbsp;<code class="keyword">Axiom</code> <a name="Ax1"></a>Ax1 : forall r t ρs ρ σ k, F ρs (ρ--&gt;σ) r k -&gt; <br/>
&nbsp;&nbsp;N (ρs++ext_ctx ρs k ρ) σ (r;k) t -&gt; <br/>
&nbsp;&nbsp;N ρs (ρ--&gt;σ) r (λk:ρ, t).<br/>

<br/>
&nbsp;<code class="keyword">Axiom</code> <a name="Ax2"></a>Ax2 : forall ρs r s,  A ρs Iota r s -&gt; N ρs Iota r s.<br/>

<br/>
&nbsp;<code class="keyword">Axiom</code> <a name="Ax3"></a>Ax3 : forall ρs ρ k, TypJ ρs [k] ρ -&gt;  A ρs ρ [k] [k].<br/>

<br/>
&nbsp;<code class="keyword">Axiom</code> <a name="Ax4"></a>Ax4 : forall ρs ρ σ r r' s s', TypJ ρs s ρ -&gt; <br/>
&nbsp;&nbsp;A ρs (ρ--&gt;σ) r r' -&gt; N ρs ρ s s' -&gt; A ρs σ (r;s) (r';s').<br/>

<br/>
&nbsp;<code class="keyword">Axiom</code> <a name="Ax5"></a>Ax5 : forall ρs ρ r s t, <br/>
&nbsp;&nbsp;H ρs ρ r s -&gt; N ρs ρ s t -&gt; N ρs ρ r t.<br/>

<br/>
&nbsp;<code class="keyword">Axiom</code> <a name="Ax6"></a>Ax6 : forall ρs ρ σ r s rs, <br/>
&nbsp;&nbsp;H ρs σ ((sub (λρ,r) rs);s) <br/>
&nbsp;&nbsp;(sub r ((s::rs)#rs.(shift))).<br/>

<br/>
&nbsp;<code class="keyword">Axiom</code> <a name="Ax7"></a>Ax7 : forall ρs ρ σ r s t, <br/>
&nbsp;&nbsp;H ρs (ρ--&gt;σ) r s -&gt; H ρs σ (r;t) (s;t).<br/>

<br/>
&nbsp;<code class="keyword">Axiom</code> <a name="Ax_H_ext_ctx"></a>Ax_H_ext_ctx :  forall ρs σs ρ r s, TypJ ρs r ρ -&gt; <br/>
&nbsp;&nbsp;H ρs ρ r s -&gt; H (ρs++σs) ρ r s.<br/>

<br/>
<code class="keyword">End</code> Requirements.<br/>

<br/>
<code class="keyword">Module</code> <a name="NormalizationProof"></a>NormalizationProof (R:Requirements).<br/>

<br/>
<code class="keyword">Import</code> R.<br/>

<br/>
<code class="keyword">Definition</code> <a name="SN"></a>SN (ρs:context)(ρ:type)(r:term) := <br/>
&nbsp;&nbsp;forall k σs, F (ρs++σs) ρ r k -&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ s:term | N (ρs++σs) ρ r s }. <br/>

<br/>
<code class="keyword">Definition</code> <a name="SA"></a>SA (ρs:context)(ρ:type)(r:term) := <br/>
&nbsp;forall k σs, F (ρs++σs) ρ r k -&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ s:term | A (ρs++σs) ρ r s }. <br/>

<br/>
Open Scope type_scope.<br/>

<br/>
<code class="keyword">Fixpoint</code> <a name="SC"></a>SC (ρs:context)(ρ:type)(r:term) {struct ρ} : Type := <br/>
&nbsp;&nbsp;(TypJ ρs r ρ) **<br/>
&nbsp;&nbsp;match ρ with <br/>
&nbsp;&nbsp;| Iota =&gt; SN ρs Iota r<br/>
&nbsp;&nbsp;| ρ--&gt;σ =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;forall s σs, SC (ρs++σs) ρ s -&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SC (ρs++σs) σ (r;s)<br/>
&nbsp;&nbsp;end.<br/>

<br/>
<code class="keyword">Lemma</code> <a name="SN_ext_ctx"></a>SN_ext_ctx : forall ρ ρs σs r, <br/>
&nbsp;TypJ ρs r ρ -&gt; SN ρs ρ r -&gt; SN (ρs++σs) ρ r.<br/>
<code class="keyword">Hint</code> Resolve SN_ext_ctx.<br/>

<br/>
<code class="keyword">Lemma</code> <a name="SC_TypJ"></a>SC_TypJ : forall ρs ρ r, SC ρs ρ r -&gt; TypJ ρs r ρ. <br/>
<code class="keyword">Hint</code> Resolve SC_TypJ.<br/>

<br/>
<code class="keyword">Lemma</code> <a name="SC_ext_ctx"></a>SC_ext_ctx : forall ρ ρs σs r, <br/>
&nbsp;SC ρs ρ r -&gt; SC (ρs++σs) ρ r.<br/>

<br/>
<code class="keyword">Lemma</code> <a name="one"></a>one :  <br/>
&nbsp;forall ρ ρs r, TypJ ρs r ρ -&gt; <br/>
&nbsp;(SC ρs ρ r -&gt; SN ρs ρ r)*(SA ρs ρ r -&gt; SC ρs ρ r).<br/>

<br/>
<code class="keyword">Lemma</code> <a name="two"></a>two : forall ρ ρs r r', TypJ ρs r ρ -&gt; <br/>
&nbsp;&nbsp;SC ρs ρ r' -&gt; H ρs ρ r r' -&gt; SC ρs ρ r.<br/>

<br/>
<code class="keyword">Fixpoint</code> <a name="SCs"></a>SCs (σs ρs: context)(rs: list term) {struct ρs} : Type := <br/>
&nbsp;match ρs, rs with <br/>
&nbsp;| nil,nil =&gt; True<br/>
&nbsp;| nil, _ =&gt; False<br/>
&nbsp;| _, nil =&gt; False <br/>
&nbsp;| ρ::ρs, r::rs =&gt; (SC σs ρ r)*(SCs σs ρs rs)<br/>
end.<br/>

<br/>
<code class="keyword">Lemma</code> <a name="SCs_length"></a>SCs_length : forall σs ρs rs, SCs σs ρs rs -&gt; <br/>
&nbsp;length ρs = length rs.<br/>
&nbsp;<br/>
<code class="keyword">Lemma</code> <a name="SCs_nth"></a>SCs_nth : forall σs ρs ρ rs r n, n &lt; length ρs -&gt;<br/>
&nbsp;&nbsp;SCs σs ρs rs -&gt; SC σs (nth n ρs ρ)  (nth n rs r).<br/>

<br/>
<code class="keyword">Lemma</code> <a name="SCs_ext_ctx"></a>SCs_ext_ctx : forall σs σs0 ρs rs, <br/>
&nbsp;SCs σs ρs rs -&gt; SCs (σs++σs0) ρs rs.<br/>

<br/>
<code class="keyword">Lemma</code> <a name="three"></a>three : forall r (rs:substitution) ρs σs ρ, <br/>
&nbsp;SCs σs ρs rs -&gt; <br/>
&nbsp;TypJ ρs r ρ -&gt;  SC σs ρ (sub r rs).<br/>

<br/>
<code class="keyword">Lemma</code> <a name="SCs_seq"></a>SCs_seq : forall ρs σs, <br/>
&nbsp;&nbsp;SCs (σs++ρs) ρs<br/>
&nbsp;&nbsp;&nbsp;(map Var (seq (length σs) (length ρs))).<br/>

<br/>
<code class="keyword">Lemma</code> <a name="normalizeTheorem"></a>normalizeTheorem : <br/>
&nbsp;forall ρs ρ r, TypJ ρs r ρ -&gt; { s:term | N ρs ρ r s }.<br/>

<br/>
<code class="keyword">End</code> NormalizationProof.<br/>
</code>
<hr/><a href="index.html">Index</a><hr/><font size="-1">This page has been generated by <a href="http://www.lri.fr/~filliatr/coqdoc/">coqdoc</a></font>
</body>
</html>