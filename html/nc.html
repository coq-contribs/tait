<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf8"><link rel="stylesheet" href="style.css" type="text/css"><title>nc</title>
</head>

<body>

<h1>Library nc</h1>

<code>

<br/>
<code class="keyword">Require</code> <code class="keyword">Import</code> minlog_mode.<br/>

<br/>
<code class="keyword">Ltac</code> dcase x := generalize (<a href="http://coq.inria.fr/library/Coq.Init.Logic.html#refl_equal">refl_equal</a> x); pattern x at -1; case x.<br/>

<br/>
<code class="keyword">Inductive</code> <a name="nc_type"></a>nc_type (A:Set) : Prop := <a name="nc"></a>nc : A -&gt; nc_type A.<br/>
<code class="keyword">Implicit</code> Arguments nc.<br/>
<code class="keyword">Notation</code> " t ! " := (<a href="nc.html#nc_type">nc_type</a> t) (at level 50).<br/>

<br/>
<code class="keyword">Inductive</code> <a name="existsnc_t"></a>existsnc_t (A : Prop) (P : A -&gt; Type) : Type :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a name="existsnc_I"></a>existsnc_I : forall x : A, P x -&gt; existsnc_t A P.<br/>

<br/>
<code class="keyword">Notation</code> "'existsnc' x : t , p" := (<a href="nc.html#existsnc_t">existsnc_t</a> (t!) (fun x =&gt; p))<br/>
&nbsp;&nbsp;(at level 200, x ident) : type_scope.<br/>

<br/>
<code class="keyword">Notation</code> "'forallnc' x : t , p" := (forall x:t!,p)<br/>
&nbsp;&nbsp;(at level 200, x ident) : type_scope.<br/>

<br/>
<code class="keyword">Notation</code> "'letnc' x := y 'in' p" := <br/>
(forall x, <a href="nc.html#nc">nc</a> x = y -&gt; p)<br/>
&nbsp;&nbsp;(at level 200, x ident) : type_scope.<br/>

<br/>
<code class="keyword">Ltac</code> existsnc_i wit := match goal with <br/>
&nbsp;&nbsp;|- (<a href="nc.html#existsnc_t">existsnc_t</a> ?A ?P) =&gt; apply (<a href="nc.html#existsnc_I">existsnc_I</a> A P (<a href="nc.html#nc">nc</a> wit))<br/>
&nbsp;end.<br/>

<br/>
Set <code class="keyword">Implicit</code> Arguments.<br/>

<br/>
<code class="keyword">Axiom</code> <a name="ProofRelevance"></a>ProofRelevance : forall (A:Set)(a b:A), <a href="nc.html#nc">nc</a> a = <a href="nc.html#nc">nc</a> b -&gt; a = b.<br/>

<br/>
<code class="keyword">Lemma</code> <a name="nc_ex"></a>nc_ex : forall (A:Set)(p: A!), exists r, p = <a href="nc.html#nc">nc</a> r.<br/>

<br/>
<code class="keyword">Definition</code> <a name="nc1"></a>nc1 (A B:Set)(f:A-&gt;B) := <br/>
&nbsp;fun (a:A!) =&gt; let (a'):=a in <a href="nc.html#nc">nc</a> (f a').<br/>

<br/>
Check <a href="nc.html#nc1">nc1</a>.<br/>
Check (<a href="nc.html#nc1">nc1</a> <a href="http://coq.inria.fr/library/Coq.Init.Peano.html#pred">pred</a>).<br/>

<br/>
<code class="keyword">Definition</code> <a name="nc2"></a>nc2 (A B C:Set)(f:A-&gt;B-&gt;C) := <br/>
&nbsp;fun (a:A!)(b:B!) =&gt; let (a'):=a in let (b'):=b in <a href="nc.html#nc">nc</a> (f a' b').<br/>

<br/>
Check <a href="nc.html#nc2">nc2</a>.<br/>
Check (<a href="nc.html#nc2">nc2</a> <a href="http://coq.inria.fr/library/Coq.Init.Peano.html#plus">plus</a>).<br/>
Check (<a href="nc.html#nc2">nc2</a> <a href="http://coq.inria.fr/library/Coq.Init.Peano.html#plus">plus</a> (<a href="nc.html#nc">nc</a> 0) (<a href="nc.html#nc">nc</a> 3)).<br/>
Eval compute in (<a href="nc.html#nc2">nc2</a> <a href="http://coq.inria.fr/library/Coq.Init.Peano.html#plus">plus</a> (<a href="nc.html#nc">nc</a> 0) (<a href="nc.html#nc">nc</a> 3)).<br/>

<br/>
<code class="keyword">Definition</code> <a name="nc3"></a>nc3 (A B C D:Set)(f:A-&gt;B-&gt;C-&gt;D) := <br/>
&nbsp;fun (a:A!)(b:B!)(c:C!) =&gt; <br/>
&nbsp;&nbsp;let (a'):=a in let (b'):=b in let (c'):=c in <a href="nc.html#nc">nc</a> (f a' b' c').<br/>

<br/>
<code class="keyword">Definition</code> <a name="ncP"></a>ncP (A:Set)(P:A-&gt;Prop) := <br/>
&nbsp;&nbsp;fun (a:A!) =&gt; letnc a':=a in P a'.<br/>

<br/>
<code class="keyword">Definition</code> <a name="ncP2"></a>ncP2 (A B:Set)(P:A-&gt;B-&gt;Prop) := <br/>
&nbsp;&nbsp;fun (a:A!)(b:B!) =&gt; letnc a':=a in letnc b':=b in P a' b'.<br/>

<br/>
<code class="keyword">Unset</code> <code class="keyword">Implicit</code> Arguments.<br/>

<br/>

<br/>
<code class="keyword">Section</code> ProofRelevance.<br/>

<br/>
<code class="keyword">Inductive</code> <a name="test"></a>test : Prop := <a name="A"></a>A | <a name="B"></a>B :test.<br/>

<br/>
<code class="keyword">Lemma</code> <a name="EqPropCons_ProofIrr"></a>EqPropCons_ProofIrr : <br/>
&nbsp;&nbsp;&nbsp;A=B &lt;-&gt; forall (P:Prop)(p p':P), p = p'.<br/>

<br/>
</code>

<table width="100%"><tr class="doc"><td>
So <code>A&lt;&gt;B</code> isn't provable in the basic system ! 
</td></tr></table>
<code>

<br/>
<code class="keyword">Lemma</code> <a name="ProofIrr_NoHope"></a>ProofIrr_NoHope : <br/>
&nbsp;&nbsp;(forall (P:Prop)(p p':P), p = p') &lt;-&gt; nc 0 = nc 1.<br/>

<br/>
</code>

<table width="100%"><tr class="doc"><td>
So the desired lemma 
     <code>forall a b:A, nc a = nc b -&gt; a=b</code>
   is in fact equivalent to (not ProofIrrelevance), which 
   isn't provable (nor provably false). 
</td></tr></table>
<code>

<br/>
<code class="keyword">End</code> ProofRelevance.<br/>

<br/>
</code>
<hr/><a href="index.html">Index</a><hr/><font size="-1">This page has been generated by <a href="http://www.lri.fr/~filliatr/coqdoc/">coqdoc</a></font>
</body>
</html>